use super::source::Source;
use crate::lex::kind::*;
use std::borrow::Borrow;
use std::marker::PhantomData;
use std::ops::Range;
use std::sync::Arc;

pub trait Buffer<'a> {
    fn token_buffer(&self) -> &TokenBuffer<'a>;
}

/// Query about a specific token with a [`TokenId`].
pub trait TokenQuery<'a> {
    fn kind(&self, token: impl Borrow<TokenId>) -> TokenKind;
    fn span(&self, token: impl Borrow<TokenId>) -> Span;
    fn as_str(&'a self, token: impl Borrow<TokenId>) -> &'a str;
}

impl<'a, T> TokenQuery<'a> for T
where
    T: Buffer<'a>,
{
    #[track_caller]
    fn kind(&self, token: impl Borrow<TokenId>) -> TokenKind {
        self.token_buffer().kind(token)
    }

    #[track_caller]
    fn span(&self, token: impl Borrow<TokenId>) -> Span {
        self.token_buffer().span(token)
    }

    fn as_str(&'a self, token: impl Borrow<TokenId>) -> &'a str {
        self.token_buffer().as_str(token)
    }
}

/// Key into a buffer containing tokens generated by the lexer.
///
/// Used in [`TokenQuery`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TokenId {
    pub index: u32,
    pub source: u32,
}

impl TokenId {
    pub fn new(index: u32, source: u32) -> Self {
        Self { index, source }
    }

    pub fn next(&self) -> Self {
        Self {
            index: self.index + 1,
            source: self.source,
        }
    }

    pub fn prev(&self) -> Option<Self> {
        self.index.checked_sub(1).and_then(|index| {
            Some(Self {
                index,
                source: self.source,
            })
        })
    }
}

/// Storage for the tokens of a source file.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TokenBuffer<'a> {
    tokens: Vec<Token>,
    source: Arc<Source>,
    /// Reference to the source file
    _phantom: PhantomData<&'a str>,
}

impl<'a> TokenBuffer<'a> {
    pub fn new(mut tokens: Vec<Token>, source: Source) -> Self {
        for token in tokens.iter_mut() {
            token.span.source = source.id as u32;
        }

        Self {
            tokens,
            source: Arc::new(source),
            _phantom: PhantomData,
        }
    }

    pub fn source_id(&self) -> usize {
        self.source.id
    }

    pub fn source(&self) -> Arc<Source> {
        self.source.clone()
    }

    pub fn source_ref(&self) -> &Source {
        &self.source
    }

    pub fn len(&self) -> usize {
        self.tokens.len()
    }

    pub fn is_empty(&self) -> bool {
        self.len() == 0
    }

    #[track_caller]
    pub fn token(&self, token: TokenId) -> Option<&Token> {
        assert_eq!(token.source as usize, self.source_id());
        self.tokens.get(token.index as usize)
    }

    #[track_caller]
    pub fn prev(&self, token: TokenId) -> Option<TokenId> {
        assert_eq!(token.source as usize, self.source_id());
        token.prev()
    }

    pub fn last(&self) -> Option<TokenId> {
        if !self.is_empty() {
            Some(TokenId::new(self.len() as u32 - 1, self.source_id() as u32))
        } else {
            None
        }
    }

    // TODO: binary search
    pub fn token_with_start(&self, start: usize) -> Option<TokenId> {
        self.tokens
            .iter()
            .enumerate()
            .find(|(_, t)| t.span.start as usize == start)
            .map(|(i, _)| TokenId::new(i as u32, self.source_id() as u32))
    }
}

impl<'a> TokenQuery<'a> for TokenBuffer<'a> {
    #[track_caller]
    fn kind(&self, token: impl Borrow<TokenId>) -> TokenKind {
        self.token(*token.borrow())
            .expect("called `TokenQuery::kind` with an invalid token id")
            .kind
    }

    #[track_caller]
    fn span(&self, token: impl Borrow<TokenId>) -> Span {
        self.token(*token.borrow())
            .expect("called `TokenQuery::span` with an invalid token id")
            .span
    }

    #[track_caller]
    fn as_str(&'a self, token: impl Borrow<TokenId>) -> &'a str {
        &self.source.source[self.span(token).range()]
    }
}

/// Metadata about a token held within a [`TokenBuffer`].
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

impl Token {
    pub fn new(kind: TokenKind, span: Span) -> Self {
        Self { kind, span }
    }
}

/// Token's position within a source.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Span {
    pub start: u32,
    pub end: u32,
    /// Points to the span's [`Source`].
    pub source: u32,
}

impl Span {
    /// Panics if `first` and `second` come from different [`Source`]s.
    #[track_caller]
    pub fn from_spans(first: Self, second: Self) -> Self {
        assert_eq!(first.source, second.source);

        if first.start > second.start {
            Self::from_spans(second, first).with_source(first.source)
        } else {
            Self::from_range_u32(first.start..second.end).with_source(first.source)
        }
    }

    pub fn range(&self) -> Range<usize> {
        self.start as usize..self.end as usize
    }

    pub fn from_range(range: Range<usize>) -> Self {
        Self {
            start: range.start as u32,
            end: range.end as u32,
            source: u32::MAX,
        }
    }

    pub fn from_range_u32(range: Range<u32>) -> Self {
        Self {
            start: range.start,
            end: range.end,
            source: u32::MAX,
        }
    }

    pub fn with_source(self, source: u32) -> Self {
        Self {
            start: self.start,
            end: self.end,
            source,
        }
    }
}
